<!DOCTYPE html>
<html>
<body>

<div class="ui">
    <div class="ui_message"></div>
    <br />
    <button class="ui_connection_button" onclick="ui_connection_button_click()"></button>
</div>

<script src="hardware.js"> </script>

<script>
    //Screens dimensions
    const screenWidth = 700;
    const screenHeight = 325;
    const marginLeft = screenWidth*0.1;
    const marginRight = 0;
    const marginUp = screenHeight*0.1;
    const marginDown = screenHeight*0.1;

    //GamePlay constants
    const gameplayHeight = screenHeight - (marginUp + marginDown);
    const gameplayWidth = screenWidth - (marginLeft + marginRight);
    const gameplayTimeView = 10000; //in millisecs
    const timeCursor = gameplayTimeView*0.3;
    const currentTimeX = marginLeft + (timeCursor/gameplayTimeView)*gameplayWidth;
    const forceTolerance = 0.5; //how much force variation is tolerated
    const maxForce = 8; //***Ne sera peut-être pas une constante
    const minForce = 1; //***Doit être updaté en fonction du vagin
    const sequenceDuration = 3000; //***Doit etre changer dynamiquement

    //Colors
    const white = '#FFFFFF';
    const mediumGray = '#9A9AA2';
    const lightGray = '#d3d3d3'; //***A changer
    const darkGreen = '99b8b0';
    const lightGreen = '#C4E1DA';
    const lightPink = '#FFDEDA';
    const lightYellow = '#FCEA81';
    const brightPink = '#FD66A0';
    const backgroundColor = white;

    //Images
    const yellowFlower = new Image();
    yellowFlower.src = 'yellowFlower.png'; 
    yellowFlower.onload = function() {
    };
    yellowFlower.onerror = function() {
        console.error('L\'image n\'a pas pu être chargée.'); // Gérer les erreurs de chargement de l'image
    };

    //Patient individual datas
    var baselineForce = 0; //***a changer
    var patientMaxForce = 4; //***a changer   

    
    var canvas = '<canvas id="myCanvas" width="'+ screenWidth+'" height="'+ screenHeight+'" style="border:2px solid #d3d3d3;">'
        document.write(canvas);
    
    var c = document.getElementById("myCanvas");
    var ctx = c.getContext("2d");
    var lastTimeStamp = 0;
    
    var cercleRatio = 0;
    var cercleX = -95; //a changer pr etre dynamique

    var reading_pressure = 0.0;

    function forceToPixel(force){
        return (screenHeight-marginDown) - (((force-minForce)/(maxForce-minForce))*gameplayHeight);
    }

    function timeToPixel(time){
        return (time/gameplayTimeView)*gameplayWidth;
    }

    function clear(){
        ctx.fillStyle = backgroundColor;
        ctx.fillRect(0, 0, screenWidth, screenHeight);
    }
    function gameLoop(timeStamp){
        window.requestAnimationFrame(gameLoop);
        clear();
        let deltaMs = timeStamp-lastTimeStamp;
        lastTimeStamp = timeStamp;

        reading_pressure = get_current_reading()[forceIndex];

        //Drawing to left side scale
        drawScale(marginLeft, marginUp, gameplayHeight, 5, mediumGray, 2)
       
        //drawing of vertical dotted lines of the cursor
        drawDottedLine(currentTimeX, marginUp, gameplayHeight, 1, lightGreen, 1)
    
        let forceRatio = (reading_pressure - minForce) / (maxForce - minForce);
        let clampedForceRatio = Math.min(Math.max(forceRatio, 0), 1);
        let forceY = marginUp + gameplayHeight * (1.0 - clampedForceRatio);

        //drawing of horizontal dotted lines of the cursor
        drawDottedLine(marginLeft-20, forceY, gameplayWidth, 0, lightGreen, 1)
        
        //drawing of the flower cursor
        ctx.drawImage(yellowFlower, currentTimeX-yellowFlower.width, forceY-yellowFlower.height, 25, 26); 

        //drawing rectangle
        let rectWidth = ((sequenceDuration/gameplayTimeView)*gameplayWidth);
        let rectHeight = (forceTolerance/(maxForce-minForce)*gameplayHeight);
        let rectY = forceToPixel(patientMaxForce) - rectHeight/2;
        drawRectangles(currentTimeX, rectY, rectWidth, rectHeight, lightGray)

        //drawing outer circle
        /*
        ctx.lineWidth = 15;
        ctx.beginPath();
        ctx.lineCap = "butt";
        ctx.strokeStyle = brightPink;
        ctx.arc(cercleX,screenHeight / 2,90,0,2*Math.PI);
        ctx.stroke();
        
        // Advancing inner circle
        cercleRatio += deltaMs / 10000;
        if(cercleRatio > 1.0)
        {
            cercleRatio = 0;
        }

        //drawing inner circle
        ctx.beginPath();
        ctx.lineWidth = 8;
        ctx.strokeStyle = lightPink;
        ctx.lineCap = "round";
        ctx.arc(cercleX,screenHeight / 2,90,0,2*Math.PI*cercleRatio);
        ctx.stroke();

        // Moving circle with wrap around
        cercleX += (screenWidth/5000)*deltaMs;
        if (cercleX >= screenWidth + 95){
            cercleX = -95
        }
        */
    }

    window.requestAnimationFrame(gameLoop);

    function drawRectangles(x, y, width, height, color){
        ctx.strokeStyle = color;
        ctx.fillStyle = color;
        ctx.beginPath();
        ctx.roundRect(x, y, width, height, [40]);
        ctx.fill();
        ctx.stroke();
    }

    function drawScale(x, y, height, numScales, color, thickness){
        //vertical bar
        ctx.beginPath();
        ctx.strokeStyle = color; 
        ctx.lineWidth = thickness;
        ctx.moveTo(x, y);
        ctx.lineTo(x, y + height);
        ctx.stroke();

        //horizontal bars
        ctx.beginPath();
        ctx.strokeStyle = color;
        ctx.lineWidth = thickness/2;

        var scaleRatio =  height/(numScales-1)

        for (let i = 0; i < numScales; i++) {

            if (i==0 || i==numScales-1){
                var positionScale = i*scaleRatio
                ctx.moveTo(x - 6, y + positionScale);
                ctx.lineTo(x + 6, y + positionScale);
                ctx.stroke();
            }
            else{
                var positionScale = i*scaleRatio
                ctx.moveTo(x - 6, y + positionScale);
                ctx.lineTo(x, y + positionScale);
                ctx.stroke();
            }
        }
    
    }

    function drawDottedLine(x, y, length, isVertical, color, thickness){
        const segmentLength = 10;
        const gapLength = 5;

        // Vertical line
        if (isVertical){
            var i = y;
            
            while (i < y + length) {
                ctx.beginPath();
                ctx.lineWidth = thickness;
                ctx.strokeStyle = color;
                ctx.moveTo(x, i);
                ctx.lineTo(x, i + segmentLength);
                ctx.stroke();
                i += segmentLength + gapLength;
            } 
        }
        // horizontal line
        else if (!isVertical) {
            var i = x;
            while (i < x + length) {
                ctx.beginPath();
                ctx.lineWidth = thickness;
                ctx.strokeStyle = color;
                ctx.moveTo(i, y);
                ctx.lineTo(i + segmentLength, y);
                ctx.stroke();
                i += segmentLength + gapLength;
            }
        }
        
    }
    

</script> 

</body>
</html>